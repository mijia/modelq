// Code generated by ModelQ
// table_constraints.go contains model for the database table [information_schema.table_constraints]

package postgres

import (
	"database/sql"
	"encoding/gob"
	"encoding/json"
	"fmt"
	"github.com/mijia/modelq/gmq"
	"strings"
)

type TableConstraints struct {
	ConstraintCatalog string `json:"constraint_catalog"`
	ConstraintSchema  string `json:"constraint_schema"`
	ConstraintName    string `json:"constraint_name"`
	TableCatalog      string `json:"table_catalog"`
	TableSchema       string `json:"table_schema"`
	TableName         string `json:"table_name"`
	ConstraintType    string `json:"constraint_type"`
	IsDeferrable      string `json:"is_deferrable"`
	InitiallyDeferred string `json:"initially_deferred"`
}

// Start of the TableConstraints APIs.

func (obj TableConstraints) String() string {
	if data, err := json.Marshal(obj); err != nil {
		return fmt.Sprintf("<TableConstraints>")
	} else {
		return string(data)
	}
}

func (obj TableConstraints) Insert(dbtx gmq.DbTx) (TableConstraints, error) {
	_, err := TableConstraintsObjs.Insert(obj).Run(dbtx)
	return obj, err
}

func (obj TableConstraints) Update(dbtx gmq.DbTx) (int64, error) {
	return 0, gmq.ErrNoPrimaryKeyDefined
}

func (obj TableConstraints) Delete(dbtx gmq.DbTx) (int64, error) {
	return 0, gmq.ErrNoPrimaryKeyDefined
}

// Start of the inner Query Api

type _TableConstraintsQuery struct {
	gmq.Query
}

func (q _TableConstraintsQuery) Where(f gmq.Filter) _TableConstraintsQuery {
	q.Query = q.Query.Where(f)
	return q
}

func (q _TableConstraintsQuery) OrderBy(by ...string) _TableConstraintsQuery {
	tBy := make([]string, 0, len(by))
	for _, b := range by {
		sortDir := ""
		if b[0] == '-' || b[0] == '+' {
			sortDir = string(b[0])
			b = b[1:]
		}
		if col, ok := TableConstraintsObjs.fcMap[b]; ok {
			tBy = append(tBy, sortDir+col)
		}
	}
	q.Query = q.Query.OrderBy(tBy...)
	return q
}

func (q _TableConstraintsQuery) GroupBy(by ...string) _TableConstraintsQuery {
	tBy := make([]string, 0, len(by))
	for _, b := range by {
		if col, ok := TableConstraintsObjs.fcMap[b]; ok {
			tBy = append(tBy, col)
		}
	}
	q.Query = q.Query.GroupBy(tBy...)
	return q
}

func (q _TableConstraintsQuery) Limit(offsets ...int64) _TableConstraintsQuery {
	q.Query = q.Query.Limit(offsets...)
	return q
}

func (q _TableConstraintsQuery) Page(number, size int) _TableConstraintsQuery {
	q.Query = q.Query.Page(number, size)
	return q
}

func (q _TableConstraintsQuery) Run(dbtx gmq.DbTx) (sql.Result, error) {
	return q.Query.Exec(dbtx)
}

type TableConstraintsRowVisitor func(obj TableConstraints) bool

func (q _TableConstraintsQuery) Iterate(dbtx gmq.DbTx, functor TableConstraintsRowVisitor) error {
	return q.Query.SelectList(dbtx, func(columns []gmq.Column, rb []sql.RawBytes) bool {
		obj := TableConstraintsObjs.toTableConstraints(columns, rb)
		return functor(obj)
	})
}

func (q _TableConstraintsQuery) One(dbtx gmq.DbTx) (TableConstraints, error) {
	var obj TableConstraints
	err := q.Query.SelectOne(dbtx, func(columns []gmq.Column, rb []sql.RawBytes) bool {
		obj = TableConstraintsObjs.toTableConstraints(columns, rb)
		return true
	})
	return obj, err
}

func (q _TableConstraintsQuery) List(dbtx gmq.DbTx) ([]TableConstraints, error) {
	result := make([]TableConstraints, 0, 10)
	err := q.Query.SelectList(dbtx, func(columns []gmq.Column, rb []sql.RawBytes) bool {
		obj := TableConstraintsObjs.toTableConstraints(columns, rb)
		result = append(result, obj)
		return true
	})
	return result, err
}

// Start of the model facade Apis.

type _TableConstraintsObjs struct {
	fcMap map[string]string
}

func (o _TableConstraintsObjs) Names() (schema, tbl, alias string) {
	return "information_schema", "table_constraints", "TableConstraints"
}

func (o _TableConstraintsObjs) Select(fields ...string) _TableConstraintsQuery {
	q := _TableConstraintsQuery{}
	if len(fields) == 0 {
		fields = []string{"ConstraintCatalog", "ConstraintSchema", "ConstraintName", "TableCatalog", "TableSchema", "TableName", "ConstraintType", "IsDeferrable", "InitiallyDeferred"}
	}
	q.Query = gmq.Select(o, o.columns(fields...))
	return q
}

func (o _TableConstraintsObjs) Insert(obj TableConstraints) _TableConstraintsQuery {
	q := _TableConstraintsQuery{}
	q.Query = gmq.Insert(o, o.columnsWithData(obj, "ConstraintCatalog", "ConstraintSchema", "ConstraintName", "TableCatalog", "TableSchema", "TableName", "ConstraintType", "IsDeferrable", "InitiallyDeferred"))
	return q
}

func (o _TableConstraintsObjs) Update(obj TableConstraints, fields ...string) _TableConstraintsQuery {
	q := _TableConstraintsQuery{}
	q.Query = gmq.Update(o, o.columnsWithData(obj, fields...))
	return q
}

func (o _TableConstraintsObjs) Delete() _TableConstraintsQuery {
	q := _TableConstraintsQuery{}
	q.Query = gmq.Delete(o)
	return q
}

///// Managed Objects Filters definition

func (o _TableConstraintsObjs) FilterConstraintCatalog(op string, p string, ps ...string) gmq.Filter {
	params := make([]interface{}, 1+len(ps))
	params[0] = p
	for i := range ps {
		params[i+1] = ps[i]
	}
	return o.newFilter("constraint_catalog", op, params...)
}

func (o _TableConstraintsObjs) FilterConstraintSchema(op string, p string, ps ...string) gmq.Filter {
	params := make([]interface{}, 1+len(ps))
	params[0] = p
	for i := range ps {
		params[i+1] = ps[i]
	}
	return o.newFilter("constraint_schema", op, params...)
}

func (o _TableConstraintsObjs) FilterConstraintName(op string, p string, ps ...string) gmq.Filter {
	params := make([]interface{}, 1+len(ps))
	params[0] = p
	for i := range ps {
		params[i+1] = ps[i]
	}
	return o.newFilter("constraint_name", op, params...)
}

func (o _TableConstraintsObjs) FilterTableCatalog(op string, p string, ps ...string) gmq.Filter {
	params := make([]interface{}, 1+len(ps))
	params[0] = p
	for i := range ps {
		params[i+1] = ps[i]
	}
	return o.newFilter("table_catalog", op, params...)
}

func (o _TableConstraintsObjs) FilterTableSchema(op string, p string, ps ...string) gmq.Filter {
	params := make([]interface{}, 1+len(ps))
	params[0] = p
	for i := range ps {
		params[i+1] = ps[i]
	}
	return o.newFilter("table_schema", op, params...)
}

func (o _TableConstraintsObjs) FilterTableName(op string, p string, ps ...string) gmq.Filter {
	params := make([]interface{}, 1+len(ps))
	params[0] = p
	for i := range ps {
		params[i+1] = ps[i]
	}
	return o.newFilter("table_name", op, params...)
}

func (o _TableConstraintsObjs) FilterConstraintType(op string, p string, ps ...string) gmq.Filter {
	params := make([]interface{}, 1+len(ps))
	params[0] = p
	for i := range ps {
		params[i+1] = ps[i]
	}
	return o.newFilter("constraint_type", op, params...)
}

func (o _TableConstraintsObjs) FilterIsDeferrable(op string, p string, ps ...string) gmq.Filter {
	params := make([]interface{}, 1+len(ps))
	params[0] = p
	for i := range ps {
		params[i+1] = ps[i]
	}
	return o.newFilter("is_deferrable", op, params...)
}

func (o _TableConstraintsObjs) FilterInitiallyDeferred(op string, p string, ps ...string) gmq.Filter {
	params := make([]interface{}, 1+len(ps))
	params[0] = p
	for i := range ps {
		params[i+1] = ps[i]
	}
	return o.newFilter("initially_deferred", op, params...)
}

///// Managed Objects Columns definition

func (o _TableConstraintsObjs) ColumnConstraintCatalog(p ...string) gmq.Column {
	var value interface{}
	if len(p) > 0 {
		value = p[0]
	}
	return gmq.Column{"constraint_catalog", value}
}

func (o _TableConstraintsObjs) ColumnConstraintSchema(p ...string) gmq.Column {
	var value interface{}
	if len(p) > 0 {
		value = p[0]
	}
	return gmq.Column{"constraint_schema", value}
}

func (o _TableConstraintsObjs) ColumnConstraintName(p ...string) gmq.Column {
	var value interface{}
	if len(p) > 0 {
		value = p[0]
	}
	return gmq.Column{"constraint_name", value}
}

func (o _TableConstraintsObjs) ColumnTableCatalog(p ...string) gmq.Column {
	var value interface{}
	if len(p) > 0 {
		value = p[0]
	}
	return gmq.Column{"table_catalog", value}
}

func (o _TableConstraintsObjs) ColumnTableSchema(p ...string) gmq.Column {
	var value interface{}
	if len(p) > 0 {
		value = p[0]
	}
	return gmq.Column{"table_schema", value}
}

func (o _TableConstraintsObjs) ColumnTableName(p ...string) gmq.Column {
	var value interface{}
	if len(p) > 0 {
		value = p[0]
	}
	return gmq.Column{"table_name", value}
}

func (o _TableConstraintsObjs) ColumnConstraintType(p ...string) gmq.Column {
	var value interface{}
	if len(p) > 0 {
		value = p[0]
	}
	return gmq.Column{"constraint_type", value}
}

func (o _TableConstraintsObjs) ColumnIsDeferrable(p ...string) gmq.Column {
	var value interface{}
	if len(p) > 0 {
		value = p[0]
	}
	return gmq.Column{"is_deferrable", value}
}

func (o _TableConstraintsObjs) ColumnInitiallyDeferred(p ...string) gmq.Column {
	var value interface{}
	if len(p) > 0 {
		value = p[0]
	}
	return gmq.Column{"initially_deferred", value}
}

////// Internal helper funcs

func (o _TableConstraintsObjs) newFilter(name, op string, params ...interface{}) gmq.Filter {
	if strings.ToUpper(op) == "IN" {
		return gmq.InFilter(name, params)
	}
	return gmq.UnitFilter(name, op, params[0])
}

func (o _TableConstraintsObjs) toTableConstraints(columns []gmq.Column, rb []sql.RawBytes) TableConstraints {
	obj := TableConstraints{}
	if len(columns) == len(rb) {
		for i := range columns {
			switch columns[i].Name {
			case "constraint_catalog":
				obj.ConstraintCatalog = gmq.AsString(rb[i])
			case "constraint_schema":
				obj.ConstraintSchema = gmq.AsString(rb[i])
			case "constraint_name":
				obj.ConstraintName = gmq.AsString(rb[i])
			case "table_catalog":
				obj.TableCatalog = gmq.AsString(rb[i])
			case "table_schema":
				obj.TableSchema = gmq.AsString(rb[i])
			case "table_name":
				obj.TableName = gmq.AsString(rb[i])
			case "constraint_type":
				obj.ConstraintType = gmq.AsString(rb[i])
			case "is_deferrable":
				obj.IsDeferrable = gmq.AsString(rb[i])
			case "initially_deferred":
				obj.InitiallyDeferred = gmq.AsString(rb[i])
			}
		}
	}
	return obj
}

func (o _TableConstraintsObjs) columns(fields ...string) []gmq.Column {
	data := make([]gmq.Column, 0, len(fields))
	for _, f := range fields {
		switch f {
		case "ConstraintCatalog":
			data = append(data, o.ColumnConstraintCatalog())
		case "ConstraintSchema":
			data = append(data, o.ColumnConstraintSchema())
		case "ConstraintName":
			data = append(data, o.ColumnConstraintName())
		case "TableCatalog":
			data = append(data, o.ColumnTableCatalog())
		case "TableSchema":
			data = append(data, o.ColumnTableSchema())
		case "TableName":
			data = append(data, o.ColumnTableName())
		case "ConstraintType":
			data = append(data, o.ColumnConstraintType())
		case "IsDeferrable":
			data = append(data, o.ColumnIsDeferrable())
		case "InitiallyDeferred":
			data = append(data, o.ColumnInitiallyDeferred())
		}
	}
	return data
}

func (o _TableConstraintsObjs) columnsWithData(obj TableConstraints, fields ...string) []gmq.Column {
	data := make([]gmq.Column, 0, len(fields))
	for _, f := range fields {
		switch f {
		case "ConstraintCatalog":
			data = append(data, o.ColumnConstraintCatalog(obj.ConstraintCatalog))
		case "ConstraintSchema":
			data = append(data, o.ColumnConstraintSchema(obj.ConstraintSchema))
		case "ConstraintName":
			data = append(data, o.ColumnConstraintName(obj.ConstraintName))
		case "TableCatalog":
			data = append(data, o.ColumnTableCatalog(obj.TableCatalog))
		case "TableSchema":
			data = append(data, o.ColumnTableSchema(obj.TableSchema))
		case "TableName":
			data = append(data, o.ColumnTableName(obj.TableName))
		case "ConstraintType":
			data = append(data, o.ColumnConstraintType(obj.ConstraintType))
		case "IsDeferrable":
			data = append(data, o.ColumnIsDeferrable(obj.IsDeferrable))
		case "InitiallyDeferred":
			data = append(data, o.ColumnInitiallyDeferred(obj.InitiallyDeferred))
		}
	}
	return data
}

var TableConstraintsObjs _TableConstraintsObjs

func init() {
	TableConstraintsObjs.fcMap = map[string]string{
		"ConstraintCatalog": "constraint_catalog",
		"ConstraintSchema":  "constraint_schema",
		"ConstraintName":    "constraint_name",
		"TableCatalog":      "table_catalog",
		"TableSchema":       "table_schema",
		"TableName":         "table_name",
		"ConstraintType":    "constraint_type",
		"IsDeferrable":      "is_deferrable",
		"InitiallyDeferred": "initially_deferred",
	}
	gob.Register(TableConstraints{})
}
