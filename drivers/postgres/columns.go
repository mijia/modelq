// Code generated by ModelQ
// columns.go contains model for the database table [information_schema.columns]

package postgres

import (
	"database/sql"
	"encoding/gob"
	"encoding/json"
	"fmt"
	"github.com/mijia/modelq/gmq"
	"strings"
)

type Columns struct {
	TableCatalog           string `json:"table_catalog"`
	TableSchema            string `json:"table_schema"`
	TableName              string `json:"table_name"`
	ColumnName             string `json:"column_name"`
	OrdinalPosition        int    `json:"ordinal_position"`
	ColumnDefault          string `json:"column_default"`
	IsNullable             string `json:"is_nullable"`
	DataType               string `json:"data_type"`
	CharacterMaximumLength int    `json:"character_maximum_length"`
	CharacterOctetLength   int    `json:"character_octet_length"`
	NumericPrecision       int    `json:"numeric_precision"`
	NumericPrecisionRadix  int    `json:"numeric_precision_radix"`
	NumericScale           int    `json:"numeric_scale"`
	DatetimePrecision      int    `json:"datetime_precision"`
	IntervalType           string `json:"interval_type"`
	IntervalPrecision      int    `json:"interval_precision"`
	CharacterSetCatalog    string `json:"character_set_catalog"`
	CharacterSetSchema     string `json:"character_set_schema"`
	CharacterSetName       string `json:"character_set_name"`
	CollationCatalog       string `json:"collation_catalog"`
	CollationSchema        string `json:"collation_schema"`
	CollationName          string `json:"collation_name"`
	DomainCatalog          string `json:"domain_catalog"`
	DomainSchema           string `json:"domain_schema"`
	DomainName             string `json:"domain_name"`
	UdtCatalog             string `json:"udt_catalog"`
	UdtSchema              string `json:"udt_schema"`
	UdtName                string `json:"udt_name"`
	ScopeCatalog           string `json:"scope_catalog"`
	ScopeSchema            string `json:"scope_schema"`
	ScopeName              string `json:"scope_name"`
	MaximumCardinality     int    `json:"maximum_cardinality"`
	DtdIdentifier          string `json:"dtd_identifier"`
	IsSelfReferencing      string `json:"is_self_referencing"`
	IsIdentity             string `json:"is_identity"`
	IdentityGeneration     string `json:"identity_generation"`
	IdentityStart          string `json:"identity_start"`
	IdentityIncrement      string `json:"identity_increment"`
	IdentityMaximum        string `json:"identity_maximum"`
	IdentityMinimum        string `json:"identity_minimum"`
	IdentityCycle          string `json:"identity_cycle"`
	IsGenerated            string `json:"is_generated"`
	GenerationExpression   string `json:"generation_expression"`
	IsUpdatable            string `json:"is_updatable"`
}

// Start of the Columns APIs.

func (obj Columns) String() string {
	if data, err := json.Marshal(obj); err != nil {
		return fmt.Sprintf("<Columns>")
	} else {
		return string(data)
	}
}

func (obj Columns) Insert(dbtx gmq.DbTx) (Columns, error) {
	_, err := ColumnsObjs.Insert(obj).Run(dbtx)
	return obj, err
}

func (obj Columns) Update(dbtx gmq.DbTx) (int64, error) {
	return 0, gmq.ErrNoPrimaryKeyDefined
}

func (obj Columns) Delete(dbtx gmq.DbTx) (int64, error) {
	return 0, gmq.ErrNoPrimaryKeyDefined
}

// Start of the inner Query Api

type _ColumnsQuery struct {
	gmq.Query
}

func (q _ColumnsQuery) Where(f gmq.Filter) _ColumnsQuery {
	q.Query = q.Query.Where(f)
	return q
}

func (q _ColumnsQuery) OrderBy(by ...string) _ColumnsQuery {
	tBy := make([]string, 0, len(by))
	for _, b := range by {
		sortDir := ""
		if b[0] == '-' || b[0] == '+' {
			sortDir = string(b[0])
			b = b[1:]
		}
		if col, ok := ColumnsObjs.fcMap[b]; ok {
			tBy = append(tBy, sortDir+col)
		}
	}
	q.Query = q.Query.OrderBy(tBy...)
	return q
}

func (q _ColumnsQuery) GroupBy(by ...string) _ColumnsQuery {
	tBy := make([]string, 0, len(by))
	for _, b := range by {
		if col, ok := ColumnsObjs.fcMap[b]; ok {
			tBy = append(tBy, col)
		}
	}
	q.Query = q.Query.GroupBy(tBy...)
	return q
}

func (q _ColumnsQuery) Limit(offsets ...int64) _ColumnsQuery {
	q.Query = q.Query.Limit(offsets...)
	return q
}

func (q _ColumnsQuery) Page(number, size int) _ColumnsQuery {
	q.Query = q.Query.Page(number, size)
	return q
}

func (q _ColumnsQuery) Run(dbtx gmq.DbTx) (sql.Result, error) {
	return q.Query.Exec(dbtx)
}

type ColumnsRowVisitor func(obj Columns) bool

func (q _ColumnsQuery) Iterate(dbtx gmq.DbTx, functor ColumnsRowVisitor) error {
	return q.Query.SelectList(dbtx, func(columns []gmq.Column, rb []sql.RawBytes) bool {
		obj := ColumnsObjs.toColumns(columns, rb)
		return functor(obj)
	})
}

func (q _ColumnsQuery) One(dbtx gmq.DbTx) (Columns, error) {
	var obj Columns
	err := q.Query.SelectOne(dbtx, func(columns []gmq.Column, rb []sql.RawBytes) bool {
		obj = ColumnsObjs.toColumns(columns, rb)
		return true
	})
	return obj, err
}

func (q _ColumnsQuery) List(dbtx gmq.DbTx) ([]Columns, error) {
	result := make([]Columns, 0, 10)
	err := q.Query.SelectList(dbtx, func(columns []gmq.Column, rb []sql.RawBytes) bool {
		obj := ColumnsObjs.toColumns(columns, rb)
		result = append(result, obj)
		return true
	})
	return result, err
}

// Start of the model facade Apis.

type _ColumnsObjs struct {
	fcMap map[string]string
}

func (o _ColumnsObjs) Names() (schema, tbl, alias string) {
	return "information_schema", "columns", "Columns"
}

func (o _ColumnsObjs) Select(fields ...string) _ColumnsQuery {
	q := _ColumnsQuery{}
	if len(fields) == 0 {
		fields = []string{"TableCatalog", "TableSchema", "TableName", "ColumnName", "OrdinalPosition", "ColumnDefault", "IsNullable", "DataType", "CharacterMaximumLength", "CharacterOctetLength", "NumericPrecision", "NumericPrecisionRadix", "NumericScale", "DatetimePrecision", "IntervalType", "IntervalPrecision", "CharacterSetCatalog", "CharacterSetSchema", "CharacterSetName", "CollationCatalog", "CollationSchema", "CollationName", "DomainCatalog", "DomainSchema", "DomainName", "UdtCatalog", "UdtSchema", "UdtName", "ScopeCatalog", "ScopeSchema", "ScopeName", "MaximumCardinality", "DtdIdentifier", "IsSelfReferencing", "IsIdentity", "IdentityGeneration", "IdentityStart", "IdentityIncrement", "IdentityMaximum", "IdentityMinimum", "IdentityCycle", "IsGenerated", "GenerationExpression", "IsUpdatable"}
	}
	q.Query = gmq.Select(o, o.columns(fields...))
	return q
}

func (o _ColumnsObjs) Insert(obj Columns) _ColumnsQuery {
	q := _ColumnsQuery{}
	q.Query = gmq.Insert(o, o.columnsWithData(obj, "TableCatalog", "TableSchema", "TableName", "ColumnName", "OrdinalPosition", "ColumnDefault", "IsNullable", "DataType", "CharacterMaximumLength", "CharacterOctetLength", "NumericPrecision", "NumericPrecisionRadix", "NumericScale", "DatetimePrecision", "IntervalType", "IntervalPrecision", "CharacterSetCatalog", "CharacterSetSchema", "CharacterSetName", "CollationCatalog", "CollationSchema", "CollationName", "DomainCatalog", "DomainSchema", "DomainName", "UdtCatalog", "UdtSchema", "UdtName", "ScopeCatalog", "ScopeSchema", "ScopeName", "MaximumCardinality", "DtdIdentifier", "IsSelfReferencing", "IsIdentity", "IdentityGeneration", "IdentityStart", "IdentityIncrement", "IdentityMaximum", "IdentityMinimum", "IdentityCycle", "IsGenerated", "GenerationExpression", "IsUpdatable"))
	return q
}

func (o _ColumnsObjs) Update(obj Columns, fields ...string) _ColumnsQuery {
	q := _ColumnsQuery{}
	q.Query = gmq.Update(o, o.columnsWithData(obj, fields...))
	return q
}

func (o _ColumnsObjs) Delete() _ColumnsQuery {
	q := _ColumnsQuery{}
	q.Query = gmq.Delete(o)
	return q
}

///// Managed Objects Filters definition

func (o _ColumnsObjs) FilterTableCatalog(op string, p string, ps ...string) gmq.Filter {
	params := make([]interface{}, 1+len(ps))
	params[0] = p
	for i := range ps {
		params[i+1] = ps[i]
	}
	return o.newFilter("table_catalog", op, params...)
}

func (o _ColumnsObjs) FilterTableSchema(op string, p string, ps ...string) gmq.Filter {
	params := make([]interface{}, 1+len(ps))
	params[0] = p
	for i := range ps {
		params[i+1] = ps[i]
	}
	return o.newFilter("table_schema", op, params...)
}

func (o _ColumnsObjs) FilterTableName(op string, p string, ps ...string) gmq.Filter {
	params := make([]interface{}, 1+len(ps))
	params[0] = p
	for i := range ps {
		params[i+1] = ps[i]
	}
	return o.newFilter("table_name", op, params...)
}

func (o _ColumnsObjs) FilterColumnName(op string, p string, ps ...string) gmq.Filter {
	params := make([]interface{}, 1+len(ps))
	params[0] = p
	for i := range ps {
		params[i+1] = ps[i]
	}
	return o.newFilter("column_name", op, params...)
}

func (o _ColumnsObjs) FilterOrdinalPosition(op string, p int, ps ...int) gmq.Filter {
	params := make([]interface{}, 1+len(ps))
	params[0] = p
	for i := range ps {
		params[i+1] = ps[i]
	}
	return o.newFilter("ordinal_position", op, params...)
}

func (o _ColumnsObjs) FilterColumnDefault(op string, p string, ps ...string) gmq.Filter {
	params := make([]interface{}, 1+len(ps))
	params[0] = p
	for i := range ps {
		params[i+1] = ps[i]
	}
	return o.newFilter("column_default", op, params...)
}

func (o _ColumnsObjs) FilterIsNullable(op string, p string, ps ...string) gmq.Filter {
	params := make([]interface{}, 1+len(ps))
	params[0] = p
	for i := range ps {
		params[i+1] = ps[i]
	}
	return o.newFilter("is_nullable", op, params...)
}

func (o _ColumnsObjs) FilterDataType(op string, p string, ps ...string) gmq.Filter {
	params := make([]interface{}, 1+len(ps))
	params[0] = p
	for i := range ps {
		params[i+1] = ps[i]
	}
	return o.newFilter("data_type", op, params...)
}

func (o _ColumnsObjs) FilterCharacterMaximumLength(op string, p int, ps ...int) gmq.Filter {
	params := make([]interface{}, 1+len(ps))
	params[0] = p
	for i := range ps {
		params[i+1] = ps[i]
	}
	return o.newFilter("character_maximum_length", op, params...)
}

func (o _ColumnsObjs) FilterCharacterOctetLength(op string, p int, ps ...int) gmq.Filter {
	params := make([]interface{}, 1+len(ps))
	params[0] = p
	for i := range ps {
		params[i+1] = ps[i]
	}
	return o.newFilter("character_octet_length", op, params...)
}

func (o _ColumnsObjs) FilterNumericPrecision(op string, p int, ps ...int) gmq.Filter {
	params := make([]interface{}, 1+len(ps))
	params[0] = p
	for i := range ps {
		params[i+1] = ps[i]
	}
	return o.newFilter("numeric_precision", op, params...)
}

func (o _ColumnsObjs) FilterNumericPrecisionRadix(op string, p int, ps ...int) gmq.Filter {
	params := make([]interface{}, 1+len(ps))
	params[0] = p
	for i := range ps {
		params[i+1] = ps[i]
	}
	return o.newFilter("numeric_precision_radix", op, params...)
}

func (o _ColumnsObjs) FilterNumericScale(op string, p int, ps ...int) gmq.Filter {
	params := make([]interface{}, 1+len(ps))
	params[0] = p
	for i := range ps {
		params[i+1] = ps[i]
	}
	return o.newFilter("numeric_scale", op, params...)
}

func (o _ColumnsObjs) FilterDatetimePrecision(op string, p int, ps ...int) gmq.Filter {
	params := make([]interface{}, 1+len(ps))
	params[0] = p
	for i := range ps {
		params[i+1] = ps[i]
	}
	return o.newFilter("datetime_precision", op, params...)
}

func (o _ColumnsObjs) FilterIntervalType(op string, p string, ps ...string) gmq.Filter {
	params := make([]interface{}, 1+len(ps))
	params[0] = p
	for i := range ps {
		params[i+1] = ps[i]
	}
	return o.newFilter("interval_type", op, params...)
}

func (o _ColumnsObjs) FilterIntervalPrecision(op string, p int, ps ...int) gmq.Filter {
	params := make([]interface{}, 1+len(ps))
	params[0] = p
	for i := range ps {
		params[i+1] = ps[i]
	}
	return o.newFilter("interval_precision", op, params...)
}

func (o _ColumnsObjs) FilterCharacterSetCatalog(op string, p string, ps ...string) gmq.Filter {
	params := make([]interface{}, 1+len(ps))
	params[0] = p
	for i := range ps {
		params[i+1] = ps[i]
	}
	return o.newFilter("character_set_catalog", op, params...)
}

func (o _ColumnsObjs) FilterCharacterSetSchema(op string, p string, ps ...string) gmq.Filter {
	params := make([]interface{}, 1+len(ps))
	params[0] = p
	for i := range ps {
		params[i+1] = ps[i]
	}
	return o.newFilter("character_set_schema", op, params...)
}

func (o _ColumnsObjs) FilterCharacterSetName(op string, p string, ps ...string) gmq.Filter {
	params := make([]interface{}, 1+len(ps))
	params[0] = p
	for i := range ps {
		params[i+1] = ps[i]
	}
	return o.newFilter("character_set_name", op, params...)
}

func (o _ColumnsObjs) FilterCollationCatalog(op string, p string, ps ...string) gmq.Filter {
	params := make([]interface{}, 1+len(ps))
	params[0] = p
	for i := range ps {
		params[i+1] = ps[i]
	}
	return o.newFilter("collation_catalog", op, params...)
}

func (o _ColumnsObjs) FilterCollationSchema(op string, p string, ps ...string) gmq.Filter {
	params := make([]interface{}, 1+len(ps))
	params[0] = p
	for i := range ps {
		params[i+1] = ps[i]
	}
	return o.newFilter("collation_schema", op, params...)
}

func (o _ColumnsObjs) FilterCollationName(op string, p string, ps ...string) gmq.Filter {
	params := make([]interface{}, 1+len(ps))
	params[0] = p
	for i := range ps {
		params[i+1] = ps[i]
	}
	return o.newFilter("collation_name", op, params...)
}

func (o _ColumnsObjs) FilterDomainCatalog(op string, p string, ps ...string) gmq.Filter {
	params := make([]interface{}, 1+len(ps))
	params[0] = p
	for i := range ps {
		params[i+1] = ps[i]
	}
	return o.newFilter("domain_catalog", op, params...)
}

func (o _ColumnsObjs) FilterDomainSchema(op string, p string, ps ...string) gmq.Filter {
	params := make([]interface{}, 1+len(ps))
	params[0] = p
	for i := range ps {
		params[i+1] = ps[i]
	}
	return o.newFilter("domain_schema", op, params...)
}

func (o _ColumnsObjs) FilterDomainName(op string, p string, ps ...string) gmq.Filter {
	params := make([]interface{}, 1+len(ps))
	params[0] = p
	for i := range ps {
		params[i+1] = ps[i]
	}
	return o.newFilter("domain_name", op, params...)
}

func (o _ColumnsObjs) FilterUdtCatalog(op string, p string, ps ...string) gmq.Filter {
	params := make([]interface{}, 1+len(ps))
	params[0] = p
	for i := range ps {
		params[i+1] = ps[i]
	}
	return o.newFilter("udt_catalog", op, params...)
}

func (o _ColumnsObjs) FilterUdtSchema(op string, p string, ps ...string) gmq.Filter {
	params := make([]interface{}, 1+len(ps))
	params[0] = p
	for i := range ps {
		params[i+1] = ps[i]
	}
	return o.newFilter("udt_schema", op, params...)
}

func (o _ColumnsObjs) FilterUdtName(op string, p string, ps ...string) gmq.Filter {
	params := make([]interface{}, 1+len(ps))
	params[0] = p
	for i := range ps {
		params[i+1] = ps[i]
	}
	return o.newFilter("udt_name", op, params...)
}

func (o _ColumnsObjs) FilterScopeCatalog(op string, p string, ps ...string) gmq.Filter {
	params := make([]interface{}, 1+len(ps))
	params[0] = p
	for i := range ps {
		params[i+1] = ps[i]
	}
	return o.newFilter("scope_catalog", op, params...)
}

func (o _ColumnsObjs) FilterScopeSchema(op string, p string, ps ...string) gmq.Filter {
	params := make([]interface{}, 1+len(ps))
	params[0] = p
	for i := range ps {
		params[i+1] = ps[i]
	}
	return o.newFilter("scope_schema", op, params...)
}

func (o _ColumnsObjs) FilterScopeName(op string, p string, ps ...string) gmq.Filter {
	params := make([]interface{}, 1+len(ps))
	params[0] = p
	for i := range ps {
		params[i+1] = ps[i]
	}
	return o.newFilter("scope_name", op, params...)
}

func (o _ColumnsObjs) FilterMaximumCardinality(op string, p int, ps ...int) gmq.Filter {
	params := make([]interface{}, 1+len(ps))
	params[0] = p
	for i := range ps {
		params[i+1] = ps[i]
	}
	return o.newFilter("maximum_cardinality", op, params...)
}

func (o _ColumnsObjs) FilterDtdIdentifier(op string, p string, ps ...string) gmq.Filter {
	params := make([]interface{}, 1+len(ps))
	params[0] = p
	for i := range ps {
		params[i+1] = ps[i]
	}
	return o.newFilter("dtd_identifier", op, params...)
}

func (o _ColumnsObjs) FilterIsSelfReferencing(op string, p string, ps ...string) gmq.Filter {
	params := make([]interface{}, 1+len(ps))
	params[0] = p
	for i := range ps {
		params[i+1] = ps[i]
	}
	return o.newFilter("is_self_referencing", op, params...)
}

func (o _ColumnsObjs) FilterIsIdentity(op string, p string, ps ...string) gmq.Filter {
	params := make([]interface{}, 1+len(ps))
	params[0] = p
	for i := range ps {
		params[i+1] = ps[i]
	}
	return o.newFilter("is_identity", op, params...)
}

func (o _ColumnsObjs) FilterIdentityGeneration(op string, p string, ps ...string) gmq.Filter {
	params := make([]interface{}, 1+len(ps))
	params[0] = p
	for i := range ps {
		params[i+1] = ps[i]
	}
	return o.newFilter("identity_generation", op, params...)
}

func (o _ColumnsObjs) FilterIdentityStart(op string, p string, ps ...string) gmq.Filter {
	params := make([]interface{}, 1+len(ps))
	params[0] = p
	for i := range ps {
		params[i+1] = ps[i]
	}
	return o.newFilter("identity_start", op, params...)
}

func (o _ColumnsObjs) FilterIdentityIncrement(op string, p string, ps ...string) gmq.Filter {
	params := make([]interface{}, 1+len(ps))
	params[0] = p
	for i := range ps {
		params[i+1] = ps[i]
	}
	return o.newFilter("identity_increment", op, params...)
}

func (o _ColumnsObjs) FilterIdentityMaximum(op string, p string, ps ...string) gmq.Filter {
	params := make([]interface{}, 1+len(ps))
	params[0] = p
	for i := range ps {
		params[i+1] = ps[i]
	}
	return o.newFilter("identity_maximum", op, params...)
}

func (o _ColumnsObjs) FilterIdentityMinimum(op string, p string, ps ...string) gmq.Filter {
	params := make([]interface{}, 1+len(ps))
	params[0] = p
	for i := range ps {
		params[i+1] = ps[i]
	}
	return o.newFilter("identity_minimum", op, params...)
}

func (o _ColumnsObjs) FilterIdentityCycle(op string, p string, ps ...string) gmq.Filter {
	params := make([]interface{}, 1+len(ps))
	params[0] = p
	for i := range ps {
		params[i+1] = ps[i]
	}
	return o.newFilter("identity_cycle", op, params...)
}

func (o _ColumnsObjs) FilterIsGenerated(op string, p string, ps ...string) gmq.Filter {
	params := make([]interface{}, 1+len(ps))
	params[0] = p
	for i := range ps {
		params[i+1] = ps[i]
	}
	return o.newFilter("is_generated", op, params...)
}

func (o _ColumnsObjs) FilterGenerationExpression(op string, p string, ps ...string) gmq.Filter {
	params := make([]interface{}, 1+len(ps))
	params[0] = p
	for i := range ps {
		params[i+1] = ps[i]
	}
	return o.newFilter("generation_expression", op, params...)
}

func (o _ColumnsObjs) FilterIsUpdatable(op string, p string, ps ...string) gmq.Filter {
	params := make([]interface{}, 1+len(ps))
	params[0] = p
	for i := range ps {
		params[i+1] = ps[i]
	}
	return o.newFilter("is_updatable", op, params...)
}

///// Managed Objects Columns definition

func (o _ColumnsObjs) ColumnTableCatalog(p ...string) gmq.Column {
	var value interface{}
	if len(p) > 0 {
		value = p[0]
	}
	return gmq.Column{"table_catalog", value}
}

func (o _ColumnsObjs) ColumnTableSchema(p ...string) gmq.Column {
	var value interface{}
	if len(p) > 0 {
		value = p[0]
	}
	return gmq.Column{"table_schema", value}
}

func (o _ColumnsObjs) ColumnTableName(p ...string) gmq.Column {
	var value interface{}
	if len(p) > 0 {
		value = p[0]
	}
	return gmq.Column{"table_name", value}
}

func (o _ColumnsObjs) ColumnColumnName(p ...string) gmq.Column {
	var value interface{}
	if len(p) > 0 {
		value = p[0]
	}
	return gmq.Column{"column_name", value}
}

func (o _ColumnsObjs) ColumnOrdinalPosition(p ...int) gmq.Column {
	var value interface{}
	if len(p) > 0 {
		value = p[0]
	}
	return gmq.Column{"ordinal_position", value}
}

func (o _ColumnsObjs) ColumnColumnDefault(p ...string) gmq.Column {
	var value interface{}
	if len(p) > 0 {
		value = p[0]
	}
	return gmq.Column{"column_default", value}
}

func (o _ColumnsObjs) ColumnIsNullable(p ...string) gmq.Column {
	var value interface{}
	if len(p) > 0 {
		value = p[0]
	}
	return gmq.Column{"is_nullable", value}
}

func (o _ColumnsObjs) ColumnDataType(p ...string) gmq.Column {
	var value interface{}
	if len(p) > 0 {
		value = p[0]
	}
	return gmq.Column{"data_type", value}
}

func (o _ColumnsObjs) ColumnCharacterMaximumLength(p ...int) gmq.Column {
	var value interface{}
	if len(p) > 0 {
		value = p[0]
	}
	return gmq.Column{"character_maximum_length", value}
}

func (o _ColumnsObjs) ColumnCharacterOctetLength(p ...int) gmq.Column {
	var value interface{}
	if len(p) > 0 {
		value = p[0]
	}
	return gmq.Column{"character_octet_length", value}
}

func (o _ColumnsObjs) ColumnNumericPrecision(p ...int) gmq.Column {
	var value interface{}
	if len(p) > 0 {
		value = p[0]
	}
	return gmq.Column{"numeric_precision", value}
}

func (o _ColumnsObjs) ColumnNumericPrecisionRadix(p ...int) gmq.Column {
	var value interface{}
	if len(p) > 0 {
		value = p[0]
	}
	return gmq.Column{"numeric_precision_radix", value}
}

func (o _ColumnsObjs) ColumnNumericScale(p ...int) gmq.Column {
	var value interface{}
	if len(p) > 0 {
		value = p[0]
	}
	return gmq.Column{"numeric_scale", value}
}

func (o _ColumnsObjs) ColumnDatetimePrecision(p ...int) gmq.Column {
	var value interface{}
	if len(p) > 0 {
		value = p[0]
	}
	return gmq.Column{"datetime_precision", value}
}

func (o _ColumnsObjs) ColumnIntervalType(p ...string) gmq.Column {
	var value interface{}
	if len(p) > 0 {
		value = p[0]
	}
	return gmq.Column{"interval_type", value}
}

func (o _ColumnsObjs) ColumnIntervalPrecision(p ...int) gmq.Column {
	var value interface{}
	if len(p) > 0 {
		value = p[0]
	}
	return gmq.Column{"interval_precision", value}
}

func (o _ColumnsObjs) ColumnCharacterSetCatalog(p ...string) gmq.Column {
	var value interface{}
	if len(p) > 0 {
		value = p[0]
	}
	return gmq.Column{"character_set_catalog", value}
}

func (o _ColumnsObjs) ColumnCharacterSetSchema(p ...string) gmq.Column {
	var value interface{}
	if len(p) > 0 {
		value = p[0]
	}
	return gmq.Column{"character_set_schema", value}
}

func (o _ColumnsObjs) ColumnCharacterSetName(p ...string) gmq.Column {
	var value interface{}
	if len(p) > 0 {
		value = p[0]
	}
	return gmq.Column{"character_set_name", value}
}

func (o _ColumnsObjs) ColumnCollationCatalog(p ...string) gmq.Column {
	var value interface{}
	if len(p) > 0 {
		value = p[0]
	}
	return gmq.Column{"collation_catalog", value}
}

func (o _ColumnsObjs) ColumnCollationSchema(p ...string) gmq.Column {
	var value interface{}
	if len(p) > 0 {
		value = p[0]
	}
	return gmq.Column{"collation_schema", value}
}

func (o _ColumnsObjs) ColumnCollationName(p ...string) gmq.Column {
	var value interface{}
	if len(p) > 0 {
		value = p[0]
	}
	return gmq.Column{"collation_name", value}
}

func (o _ColumnsObjs) ColumnDomainCatalog(p ...string) gmq.Column {
	var value interface{}
	if len(p) > 0 {
		value = p[0]
	}
	return gmq.Column{"domain_catalog", value}
}

func (o _ColumnsObjs) ColumnDomainSchema(p ...string) gmq.Column {
	var value interface{}
	if len(p) > 0 {
		value = p[0]
	}
	return gmq.Column{"domain_schema", value}
}

func (o _ColumnsObjs) ColumnDomainName(p ...string) gmq.Column {
	var value interface{}
	if len(p) > 0 {
		value = p[0]
	}
	return gmq.Column{"domain_name", value}
}

func (o _ColumnsObjs) ColumnUdtCatalog(p ...string) gmq.Column {
	var value interface{}
	if len(p) > 0 {
		value = p[0]
	}
	return gmq.Column{"udt_catalog", value}
}

func (o _ColumnsObjs) ColumnUdtSchema(p ...string) gmq.Column {
	var value interface{}
	if len(p) > 0 {
		value = p[0]
	}
	return gmq.Column{"udt_schema", value}
}

func (o _ColumnsObjs) ColumnUdtName(p ...string) gmq.Column {
	var value interface{}
	if len(p) > 0 {
		value = p[0]
	}
	return gmq.Column{"udt_name", value}
}

func (o _ColumnsObjs) ColumnScopeCatalog(p ...string) gmq.Column {
	var value interface{}
	if len(p) > 0 {
		value = p[0]
	}
	return gmq.Column{"scope_catalog", value}
}

func (o _ColumnsObjs) ColumnScopeSchema(p ...string) gmq.Column {
	var value interface{}
	if len(p) > 0 {
		value = p[0]
	}
	return gmq.Column{"scope_schema", value}
}

func (o _ColumnsObjs) ColumnScopeName(p ...string) gmq.Column {
	var value interface{}
	if len(p) > 0 {
		value = p[0]
	}
	return gmq.Column{"scope_name", value}
}

func (o _ColumnsObjs) ColumnMaximumCardinality(p ...int) gmq.Column {
	var value interface{}
	if len(p) > 0 {
		value = p[0]
	}
	return gmq.Column{"maximum_cardinality", value}
}

func (o _ColumnsObjs) ColumnDtdIdentifier(p ...string) gmq.Column {
	var value interface{}
	if len(p) > 0 {
		value = p[0]
	}
	return gmq.Column{"dtd_identifier", value}
}

func (o _ColumnsObjs) ColumnIsSelfReferencing(p ...string) gmq.Column {
	var value interface{}
	if len(p) > 0 {
		value = p[0]
	}
	return gmq.Column{"is_self_referencing", value}
}

func (o _ColumnsObjs) ColumnIsIdentity(p ...string) gmq.Column {
	var value interface{}
	if len(p) > 0 {
		value = p[0]
	}
	return gmq.Column{"is_identity", value}
}

func (o _ColumnsObjs) ColumnIdentityGeneration(p ...string) gmq.Column {
	var value interface{}
	if len(p) > 0 {
		value = p[0]
	}
	return gmq.Column{"identity_generation", value}
}

func (o _ColumnsObjs) ColumnIdentityStart(p ...string) gmq.Column {
	var value interface{}
	if len(p) > 0 {
		value = p[0]
	}
	return gmq.Column{"identity_start", value}
}

func (o _ColumnsObjs) ColumnIdentityIncrement(p ...string) gmq.Column {
	var value interface{}
	if len(p) > 0 {
		value = p[0]
	}
	return gmq.Column{"identity_increment", value}
}

func (o _ColumnsObjs) ColumnIdentityMaximum(p ...string) gmq.Column {
	var value interface{}
	if len(p) > 0 {
		value = p[0]
	}
	return gmq.Column{"identity_maximum", value}
}

func (o _ColumnsObjs) ColumnIdentityMinimum(p ...string) gmq.Column {
	var value interface{}
	if len(p) > 0 {
		value = p[0]
	}
	return gmq.Column{"identity_minimum", value}
}

func (o _ColumnsObjs) ColumnIdentityCycle(p ...string) gmq.Column {
	var value interface{}
	if len(p) > 0 {
		value = p[0]
	}
	return gmq.Column{"identity_cycle", value}
}

func (o _ColumnsObjs) ColumnIsGenerated(p ...string) gmq.Column {
	var value interface{}
	if len(p) > 0 {
		value = p[0]
	}
	return gmq.Column{"is_generated", value}
}

func (o _ColumnsObjs) ColumnGenerationExpression(p ...string) gmq.Column {
	var value interface{}
	if len(p) > 0 {
		value = p[0]
	}
	return gmq.Column{"generation_expression", value}
}

func (o _ColumnsObjs) ColumnIsUpdatable(p ...string) gmq.Column {
	var value interface{}
	if len(p) > 0 {
		value = p[0]
	}
	return gmq.Column{"is_updatable", value}
}

////// Internal helper funcs

func (o _ColumnsObjs) newFilter(name, op string, params ...interface{}) gmq.Filter {
	if strings.ToUpper(op) == "IN" {
		return gmq.InFilter(name, params)
	}
	return gmq.UnitFilter(name, op, params[0])
}

func (o _ColumnsObjs) toColumns(columns []gmq.Column, rb []sql.RawBytes) Columns {
	obj := Columns{}
	if len(columns) == len(rb) {
		for i := range columns {
			switch columns[i].Name {
			case "table_catalog":
				obj.TableCatalog = gmq.AsString(rb[i])
			case "table_schema":
				obj.TableSchema = gmq.AsString(rb[i])
			case "table_name":
				obj.TableName = gmq.AsString(rb[i])
			case "column_name":
				obj.ColumnName = gmq.AsString(rb[i])
			case "ordinal_position":
				obj.OrdinalPosition = gmq.AsInt(rb[i])
			case "column_default":
				obj.ColumnDefault = gmq.AsString(rb[i])
			case "is_nullable":
				obj.IsNullable = gmq.AsString(rb[i])
			case "data_type":
				obj.DataType = gmq.AsString(rb[i])
			case "character_maximum_length":
				obj.CharacterMaximumLength = gmq.AsInt(rb[i])
			case "character_octet_length":
				obj.CharacterOctetLength = gmq.AsInt(rb[i])
			case "numeric_precision":
				obj.NumericPrecision = gmq.AsInt(rb[i])
			case "numeric_precision_radix":
				obj.NumericPrecisionRadix = gmq.AsInt(rb[i])
			case "numeric_scale":
				obj.NumericScale = gmq.AsInt(rb[i])
			case "datetime_precision":
				obj.DatetimePrecision = gmq.AsInt(rb[i])
			case "interval_type":
				obj.IntervalType = gmq.AsString(rb[i])
			case "interval_precision":
				obj.IntervalPrecision = gmq.AsInt(rb[i])
			case "character_set_catalog":
				obj.CharacterSetCatalog = gmq.AsString(rb[i])
			case "character_set_schema":
				obj.CharacterSetSchema = gmq.AsString(rb[i])
			case "character_set_name":
				obj.CharacterSetName = gmq.AsString(rb[i])
			case "collation_catalog":
				obj.CollationCatalog = gmq.AsString(rb[i])
			case "collation_schema":
				obj.CollationSchema = gmq.AsString(rb[i])
			case "collation_name":
				obj.CollationName = gmq.AsString(rb[i])
			case "domain_catalog":
				obj.DomainCatalog = gmq.AsString(rb[i])
			case "domain_schema":
				obj.DomainSchema = gmq.AsString(rb[i])
			case "domain_name":
				obj.DomainName = gmq.AsString(rb[i])
			case "udt_catalog":
				obj.UdtCatalog = gmq.AsString(rb[i])
			case "udt_schema":
				obj.UdtSchema = gmq.AsString(rb[i])
			case "udt_name":
				obj.UdtName = gmq.AsString(rb[i])
			case "scope_catalog":
				obj.ScopeCatalog = gmq.AsString(rb[i])
			case "scope_schema":
				obj.ScopeSchema = gmq.AsString(rb[i])
			case "scope_name":
				obj.ScopeName = gmq.AsString(rb[i])
			case "maximum_cardinality":
				obj.MaximumCardinality = gmq.AsInt(rb[i])
			case "dtd_identifier":
				obj.DtdIdentifier = gmq.AsString(rb[i])
			case "is_self_referencing":
				obj.IsSelfReferencing = gmq.AsString(rb[i])
			case "is_identity":
				obj.IsIdentity = gmq.AsString(rb[i])
			case "identity_generation":
				obj.IdentityGeneration = gmq.AsString(rb[i])
			case "identity_start":
				obj.IdentityStart = gmq.AsString(rb[i])
			case "identity_increment":
				obj.IdentityIncrement = gmq.AsString(rb[i])
			case "identity_maximum":
				obj.IdentityMaximum = gmq.AsString(rb[i])
			case "identity_minimum":
				obj.IdentityMinimum = gmq.AsString(rb[i])
			case "identity_cycle":
				obj.IdentityCycle = gmq.AsString(rb[i])
			case "is_generated":
				obj.IsGenerated = gmq.AsString(rb[i])
			case "generation_expression":
				obj.GenerationExpression = gmq.AsString(rb[i])
			case "is_updatable":
				obj.IsUpdatable = gmq.AsString(rb[i])
			}
		}
	}
	return obj
}

func (o _ColumnsObjs) columns(fields ...string) []gmq.Column {
	data := make([]gmq.Column, 0, len(fields))
	for _, f := range fields {
		switch f {
		case "TableCatalog":
			data = append(data, o.ColumnTableCatalog())
		case "TableSchema":
			data = append(data, o.ColumnTableSchema())
		case "TableName":
			data = append(data, o.ColumnTableName())
		case "ColumnName":
			data = append(data, o.ColumnColumnName())
		case "OrdinalPosition":
			data = append(data, o.ColumnOrdinalPosition())
		case "ColumnDefault":
			data = append(data, o.ColumnColumnDefault())
		case "IsNullable":
			data = append(data, o.ColumnIsNullable())
		case "DataType":
			data = append(data, o.ColumnDataType())
		case "CharacterMaximumLength":
			data = append(data, o.ColumnCharacterMaximumLength())
		case "CharacterOctetLength":
			data = append(data, o.ColumnCharacterOctetLength())
		case "NumericPrecision":
			data = append(data, o.ColumnNumericPrecision())
		case "NumericPrecisionRadix":
			data = append(data, o.ColumnNumericPrecisionRadix())
		case "NumericScale":
			data = append(data, o.ColumnNumericScale())
		case "DatetimePrecision":
			data = append(data, o.ColumnDatetimePrecision())
		case "IntervalType":
			data = append(data, o.ColumnIntervalType())
		case "IntervalPrecision":
			data = append(data, o.ColumnIntervalPrecision())
		case "CharacterSetCatalog":
			data = append(data, o.ColumnCharacterSetCatalog())
		case "CharacterSetSchema":
			data = append(data, o.ColumnCharacterSetSchema())
		case "CharacterSetName":
			data = append(data, o.ColumnCharacterSetName())
		case "CollationCatalog":
			data = append(data, o.ColumnCollationCatalog())
		case "CollationSchema":
			data = append(data, o.ColumnCollationSchema())
		case "CollationName":
			data = append(data, o.ColumnCollationName())
		case "DomainCatalog":
			data = append(data, o.ColumnDomainCatalog())
		case "DomainSchema":
			data = append(data, o.ColumnDomainSchema())
		case "DomainName":
			data = append(data, o.ColumnDomainName())
		case "UdtCatalog":
			data = append(data, o.ColumnUdtCatalog())
		case "UdtSchema":
			data = append(data, o.ColumnUdtSchema())
		case "UdtName":
			data = append(data, o.ColumnUdtName())
		case "ScopeCatalog":
			data = append(data, o.ColumnScopeCatalog())
		case "ScopeSchema":
			data = append(data, o.ColumnScopeSchema())
		case "ScopeName":
			data = append(data, o.ColumnScopeName())
		case "MaximumCardinality":
			data = append(data, o.ColumnMaximumCardinality())
		case "DtdIdentifier":
			data = append(data, o.ColumnDtdIdentifier())
		case "IsSelfReferencing":
			data = append(data, o.ColumnIsSelfReferencing())
		case "IsIdentity":
			data = append(data, o.ColumnIsIdentity())
		case "IdentityGeneration":
			data = append(data, o.ColumnIdentityGeneration())
		case "IdentityStart":
			data = append(data, o.ColumnIdentityStart())
		case "IdentityIncrement":
			data = append(data, o.ColumnIdentityIncrement())
		case "IdentityMaximum":
			data = append(data, o.ColumnIdentityMaximum())
		case "IdentityMinimum":
			data = append(data, o.ColumnIdentityMinimum())
		case "IdentityCycle":
			data = append(data, o.ColumnIdentityCycle())
		case "IsGenerated":
			data = append(data, o.ColumnIsGenerated())
		case "GenerationExpression":
			data = append(data, o.ColumnGenerationExpression())
		case "IsUpdatable":
			data = append(data, o.ColumnIsUpdatable())
		}
	}
	return data
}

func (o _ColumnsObjs) columnsWithData(obj Columns, fields ...string) []gmq.Column {
	data := make([]gmq.Column, 0, len(fields))
	for _, f := range fields {
		switch f {
		case "TableCatalog":
			data = append(data, o.ColumnTableCatalog(obj.TableCatalog))
		case "TableSchema":
			data = append(data, o.ColumnTableSchema(obj.TableSchema))
		case "TableName":
			data = append(data, o.ColumnTableName(obj.TableName))
		case "ColumnName":
			data = append(data, o.ColumnColumnName(obj.ColumnName))
		case "OrdinalPosition":
			data = append(data, o.ColumnOrdinalPosition(obj.OrdinalPosition))
		case "ColumnDefault":
			data = append(data, o.ColumnColumnDefault(obj.ColumnDefault))
		case "IsNullable":
			data = append(data, o.ColumnIsNullable(obj.IsNullable))
		case "DataType":
			data = append(data, o.ColumnDataType(obj.DataType))
		case "CharacterMaximumLength":
			data = append(data, o.ColumnCharacterMaximumLength(obj.CharacterMaximumLength))
		case "CharacterOctetLength":
			data = append(data, o.ColumnCharacterOctetLength(obj.CharacterOctetLength))
		case "NumericPrecision":
			data = append(data, o.ColumnNumericPrecision(obj.NumericPrecision))
		case "NumericPrecisionRadix":
			data = append(data, o.ColumnNumericPrecisionRadix(obj.NumericPrecisionRadix))
		case "NumericScale":
			data = append(data, o.ColumnNumericScale(obj.NumericScale))
		case "DatetimePrecision":
			data = append(data, o.ColumnDatetimePrecision(obj.DatetimePrecision))
		case "IntervalType":
			data = append(data, o.ColumnIntervalType(obj.IntervalType))
		case "IntervalPrecision":
			data = append(data, o.ColumnIntervalPrecision(obj.IntervalPrecision))
		case "CharacterSetCatalog":
			data = append(data, o.ColumnCharacterSetCatalog(obj.CharacterSetCatalog))
		case "CharacterSetSchema":
			data = append(data, o.ColumnCharacterSetSchema(obj.CharacterSetSchema))
		case "CharacterSetName":
			data = append(data, o.ColumnCharacterSetName(obj.CharacterSetName))
		case "CollationCatalog":
			data = append(data, o.ColumnCollationCatalog(obj.CollationCatalog))
		case "CollationSchema":
			data = append(data, o.ColumnCollationSchema(obj.CollationSchema))
		case "CollationName":
			data = append(data, o.ColumnCollationName(obj.CollationName))
		case "DomainCatalog":
			data = append(data, o.ColumnDomainCatalog(obj.DomainCatalog))
		case "DomainSchema":
			data = append(data, o.ColumnDomainSchema(obj.DomainSchema))
		case "DomainName":
			data = append(data, o.ColumnDomainName(obj.DomainName))
		case "UdtCatalog":
			data = append(data, o.ColumnUdtCatalog(obj.UdtCatalog))
		case "UdtSchema":
			data = append(data, o.ColumnUdtSchema(obj.UdtSchema))
		case "UdtName":
			data = append(data, o.ColumnUdtName(obj.UdtName))
		case "ScopeCatalog":
			data = append(data, o.ColumnScopeCatalog(obj.ScopeCatalog))
		case "ScopeSchema":
			data = append(data, o.ColumnScopeSchema(obj.ScopeSchema))
		case "ScopeName":
			data = append(data, o.ColumnScopeName(obj.ScopeName))
		case "MaximumCardinality":
			data = append(data, o.ColumnMaximumCardinality(obj.MaximumCardinality))
		case "DtdIdentifier":
			data = append(data, o.ColumnDtdIdentifier(obj.DtdIdentifier))
		case "IsSelfReferencing":
			data = append(data, o.ColumnIsSelfReferencing(obj.IsSelfReferencing))
		case "IsIdentity":
			data = append(data, o.ColumnIsIdentity(obj.IsIdentity))
		case "IdentityGeneration":
			data = append(data, o.ColumnIdentityGeneration(obj.IdentityGeneration))
		case "IdentityStart":
			data = append(data, o.ColumnIdentityStart(obj.IdentityStart))
		case "IdentityIncrement":
			data = append(data, o.ColumnIdentityIncrement(obj.IdentityIncrement))
		case "IdentityMaximum":
			data = append(data, o.ColumnIdentityMaximum(obj.IdentityMaximum))
		case "IdentityMinimum":
			data = append(data, o.ColumnIdentityMinimum(obj.IdentityMinimum))
		case "IdentityCycle":
			data = append(data, o.ColumnIdentityCycle(obj.IdentityCycle))
		case "IsGenerated":
			data = append(data, o.ColumnIsGenerated(obj.IsGenerated))
		case "GenerationExpression":
			data = append(data, o.ColumnGenerationExpression(obj.GenerationExpression))
		case "IsUpdatable":
			data = append(data, o.ColumnIsUpdatable(obj.IsUpdatable))
		}
	}
	return data
}

var ColumnsObjs _ColumnsObjs

func init() {
	ColumnsObjs.fcMap = map[string]string{
		"TableCatalog":           "table_catalog",
		"TableSchema":            "table_schema",
		"TableName":              "table_name",
		"ColumnName":             "column_name",
		"OrdinalPosition":        "ordinal_position",
		"ColumnDefault":          "column_default",
		"IsNullable":             "is_nullable",
		"DataType":               "data_type",
		"CharacterMaximumLength": "character_maximum_length",
		"CharacterOctetLength":   "character_octet_length",
		"NumericPrecision":       "numeric_precision",
		"NumericPrecisionRadix":  "numeric_precision_radix",
		"NumericScale":           "numeric_scale",
		"DatetimePrecision":      "datetime_precision",
		"IntervalType":           "interval_type",
		"IntervalPrecision":      "interval_precision",
		"CharacterSetCatalog":    "character_set_catalog",
		"CharacterSetSchema":     "character_set_schema",
		"CharacterSetName":       "character_set_name",
		"CollationCatalog":       "collation_catalog",
		"CollationSchema":        "collation_schema",
		"CollationName":          "collation_name",
		"DomainCatalog":          "domain_catalog",
		"DomainSchema":           "domain_schema",
		"DomainName":             "domain_name",
		"UdtCatalog":             "udt_catalog",
		"UdtSchema":              "udt_schema",
		"UdtName":                "udt_name",
		"ScopeCatalog":           "scope_catalog",
		"ScopeSchema":            "scope_schema",
		"ScopeName":              "scope_name",
		"MaximumCardinality":     "maximum_cardinality",
		"DtdIdentifier":          "dtd_identifier",
		"IsSelfReferencing":      "is_self_referencing",
		"IsIdentity":             "is_identity",
		"IdentityGeneration":     "identity_generation",
		"IdentityStart":          "identity_start",
		"IdentityIncrement":      "identity_increment",
		"IdentityMaximum":        "identity_maximum",
		"IdentityMinimum":        "identity_minimum",
		"IdentityCycle":          "identity_cycle",
		"IsGenerated":            "is_generated",
		"GenerationExpression":   "generation_expression",
		"IsUpdatable":            "is_updatable",
	}
	gob.Register(Columns{})
}
